#ifndef auto_schedule_true_SCHEDULE_H
#define auto_schedule_true_SCHEDULE_H

// MACHINE GENERATED -- DO NOT EDIT
// This schedule was automatically generated by Mullapudi2016
// for target=x86-64-linux-avx-avx2-f16c-fma-sse41  // NOLINT
// with machine_params=32,16777216,40

#include "Halide.h"


inline void apply_schedule_auto_schedule_true(
    ::Halide::Pipeline pipeline,
    ::Halide::Target target
) {
    using ::Halide::Func;
    using ::Halide::MemoryType;
    using ::Halide::RVar;
    using ::Halide::TailStrategy;
    using ::Halide::Var;
    Var x_vi("x_vi");
    Var x_vo("x_vo");

    Func output = pipeline.get_func(3);
    Func poisson_jacobi_1 = pipeline.get_func(2);

    {
        Var x = output.args()[0];
        Var y = output.args()[1];
        Var c = output.args()[2];
        output
            .compute_root()
            .split(x, x_vo, x_vi, 32)
            .vectorize(x_vi)
            .parallel(c)
            .parallel(y);
    }
    {
        Var x = poisson_jacobi_1.args()[0];
        Var t = poisson_jacobi_1.args()[3];
        RVar r$x(poisson_jacobi_1.update(0).get_schedule().rvars()[0].var);
        RVar r$y(poisson_jacobi_1.update(0).get_schedule().rvars()[1].var);
        RVar r$z(poisson_jacobi_1.update(0).get_schedule().rvars()[2].var);
        poisson_jacobi_1
            .compute_root()
            .split(x, x_vo, x_vi, 8)
            .vectorize(x_vi)
            .parallel(t);
        poisson_jacobi_1.update(0)
            .reorder(r$x, r$y, c, r$z)
            .reorder(r$z, c)
            .parallel(c);
    }


}

#endif  // auto_schedule_true_SCHEDULE_H
